from src import WorkflowPaths, Args, validate_config
import json
import os

config = validate_config(config) # validate the Snakemake config
paths = WorkflowPaths(config) # object handling the paths to the files that will be created
args = Args(paths, config) # object handling the arguments passed to the workflow
# Name of the conda environment to use for rules (can be overridden in config)
# CONDA_ENV = config.get("conda_name", "sopa")
CONDA_ENV = os.environ.get("SOPA_CONDA_ENV", config.get("conda_name", "sopa"))
print(f"[Sopa] Using conda environment: {CONDA_ENV}")

### Segmentation rules
include: "rules/utils.smk"
include: "rules/cellpose.smk"
include: "rules/comseg.smk"
include: "rules/baysor.smk"
include: "rules/proseg.smk"
include: "rules/stardist.smk"

localrules: all
### Per-method explorer targets: create separate explorer outputs when
### requested (e.g. `.cellpose.explorer` and `.proseg.explorer`). This
### allows a single Snakemake run to produce two explorer snapshots.
explorer_cellpose = paths.sdata_path.with_suffix(".cellpose.explorer") / "experiment.xenium"
explorer_proseg = paths.sdata_path.with_suffix(".proseg.explorer") / "experiment.xenium"

# Compute final explorer targets depending on requested segmentation methods
explorer_targets = []
if args.use("cellpose"):
    explorer_targets.append(explorer_cellpose)
if args.use("proseg"):
    explorer_targets.append(explorer_proseg)
if not explorer_targets:
    explorer_targets.append(paths.explorer_experiment)

rule all:
    input:
        paths.annotations if args.annotate else [],
        *explorer_targets,
        paths.smk_explorer_raw,
        paths.report,
    params:
        sdata_path = paths.sdata_path,
        explorer_directory = paths.explorer_directory,
        explorer_experiment = paths.explorer_experiment,
        report = paths.report,
    shell:
        """
        echo ðŸŽ‰ Successfully run sopa
        echo â†’ SpatialData output directory: {params.sdata_path}
        echo â†’ Explorer output directory: {params.explorer_directory}
        echo â†’ Open the sopa report: 'open {params.report}'
        echo â†’ Open the result in the explorer: 'open {params.explorer_experiment}'
        """

rule to_spatialdata:
    input:
        [] if config["is_toy_reader"] else paths.data_path,
    output:
        paths.sdata_zgroup if paths.data_path else [],
    conda:
        CONDA_ENV
    params:
        reader = args['read'].as_cli(),
        data_path = paths.data_path,
        sdata_path = paths.sdata_path,
    shell:
        """
        sopa convert {params.data_path} --sdata-path {params.sdata_path} {params.reader}
        """

rule tissue_segmentation:
    input:
        paths.sdata_zgroup if paths.data_path else [],
    output:
        touch(paths.segmentation_done("tissue")),
    conda:
        CONDA_ENV
    params:
        tissue_segmentation = args["segmentation"]["tissue"].as_cli(),
        sdata_path = paths.sdata_path,
    shell:
        """
        sopa segmentation tissue {params.sdata_path} {params.tissue_segmentation}
        """

checkpoint patchify_image:
    input:
        paths.sdata_zgroup,
        paths.segmentation_done("tissue") if args.use("tissue") else [],
    output:
        patches_file = paths.smk_patches_file_image,
        patches = touch(paths.smk_patches),
    params:
        patchify_image = args["patchify"].as_cli(contains="pixel"),
        sdata_path = paths.sdata_path,
    conda:
        CONDA_ENV
    shell:
        """
        sopa patchify image {params.sdata_path} {params.patchify_image}
        """

checkpoint patchify_transcripts:
    input:
        paths.sdata_zgroup,
        paths.segmentation_done("cellpose") if args.use("cellpose") else [],
        paths.segmentation_done("tissue") if args.use("tissue") else [],
    output:
        directory(paths.smk_transcripts_temp_dir),
        patches_file = paths.smk_patches_file_transcripts,
    params:
        patchify_transcripts = args.patchify_transcripts(),
        sdata_path = paths.sdata_path,
    conda:
        CONDA_ENV
    shell:
        """
        sopa patchify transcripts {params.sdata_path} {params.patchify_transcripts}
        """

rule aggregate:
    input:
        args.segmentation_boundaries(),
    output:
        touch(paths.smk_aggregation),
    conda:
        CONDA_ENV
    params:
        aggregate = args["aggregate"].as_cli(),
        sdata_path = paths.sdata_path,
    shell:
        """
        sopa aggregate {params.sdata_path} {params.aggregate}
        """


rule aggregate_cellpose:
    input:
        args.segmentation_boundaries(),
        paths.segmentation_done("cellpose"),
    output:
        touch(getattr(paths, 'smk_aggregation_cellpose', paths.smk_aggregation)),
    conda:
        CONDA_ENV
    params:
        sdata_path = paths.sdata_path,
        aggregate = args["aggregate"].as_cli(),
    shell:
        """
        sopa aggregate {params.sdata_path} {params.aggregate} --method-name cellpose_boundaries --key-added cellpose_table
        """


rule aggregate_proseg:
    input:
        args.segmentation_boundaries(),
        paths.segmentation_done("proseg"),
    output:
        touch(getattr(paths, 'smk_aggregation_proseg', paths.smk_aggregation)),
    conda:
        CONDA_ENV
    params:
        sdata_path = paths.sdata_path,
        aggregate = args["aggregate"].as_cli(),
    shell:
        """
        sopa aggregate {params.sdata_path} {params.aggregate} --method-name proseg_boundaries --key-added proseg_table
        """

rule annotate:
    input:
        paths.smk_aggregation,
    output:
        directory(paths.annotations),
    conda:
        CONDA_ENV
    resources:
        partition="gpgpuq" if args['annotation']['method'] == "tangram" else "shortq",
        gpu="a100:1" if args['annotation']['method'] == "tangram" else 0,
    params:
        method_name = args['annotation']['method'],
        annotation = args['annotation']['args'].as_cli(),
        sdata_path = paths.sdata_path,
    shell:
        """
        sopa annotate {params.method_name} {params.sdata_path} {params.annotation}
        """

rule scanpy_preprocess:
    input:
        args.segmentation_boundaries(),
        paths.smk_aggregation,
        paths.annotations if args.annotate else [],
    output:
        paths.smk_scanpy_preprocess,
    params:
        sdata_path = paths.sdata_path,
        scanpy_preprocess = args["scanpy_preprocess"].as_cli(),
    conda:
        CONDA_ENV
    shell:
        """
        sopa scanpy-preprocess {params.sdata_path} {params.scanpy_preprocess}
        """

rule explorer_raw:
    input:
        paths.sdata_zgroup,
    output:
        touch(paths.smk_explorer_raw),
    conda:
        CONDA_ENV
    params:
        explorer = args["explorer"].as_cli(keys=['lazy', 'ram_threshold_gb', 'pixel_size', 'pixelsize']),
        sdata_path = paths.sdata_path,
        explorer_directory = paths.explorer_directory,
    shell:
        """
        sopa explorer write {params.sdata_path} --output-path {params.explorer_directory} {params.explorer} --mode "+it" --no-save-h5ad
        """


rule explorer_cellpose:
    input:
        args.segmentation_boundaries(),
        getattr(paths, 'smk_aggregation_cellpose', paths.smk_aggregation),
        paths.segmentation_done("cellpose"),
        paths.smk_explorer_raw,
        paths.annotations if args.annotate else [],
    output:
        explorer_cellpose,
    conda:
        CONDA_ENV
    params:
        # Ensure the Explorer uses the cellpose boundaries for this snapshot; do nothing
        # if the user already provided a `--shapes-key` via the `explorer` config.
        explorer = lambda wildcards, input, output: (
            args["explorer"].as_cli()
            + ("" if "--shapes-key" in args["explorer"].as_cli() else " --shapes-key cellpose_boundaries")
            + ("" if "--table-key" in args["explorer"].as_cli() else " --table-key cellpose_table")
        ),
        sdata_path = paths.sdata_path,
        explorer_directory = str(paths.sdata_path) + ".cellpose.explorer",
    shell:
        """
        sopa explorer write {params.sdata_path} --output-path {params.explorer_directory} {params.explorer} --mode "+it"
        """


rule explorer_proseg:
    input:
        args.segmentation_boundaries(),
        getattr(paths, 'smk_aggregation_proseg', paths.smk_aggregation),
        paths.segmentation_done("proseg"),
        paths.smk_explorer_raw,
        paths.annotations if args.annotate else [],
    output:
        explorer_proseg,
    conda:
        CONDA_ENV
    params:
        # Ensure the Explorer uses the proseg boundaries for this snapshot; do nothing
        # if the user already provided a `--shapes-key` via the `explorer` config.
        explorer = lambda wildcards, input, output: (
            args["explorer"].as_cli()
            + ("" if "--shapes-key" in args["explorer"].as_cli() else " --shapes-key proseg_boundaries")
            + ("" if "--table-key" in args["explorer"].as_cli() else " --table-key proseg_table")
        ),
        sdata_path = paths.sdata_path,
        explorer_directory = str(paths.sdata_path) + ".proseg.explorer",
    shell:
        """
        sopa explorer write {params.sdata_path} --output-path {params.explorer_directory} {params.explorer} --mode "+it"
        """

rule explorer:
    input:
        args.segmentation_boundaries(),
        paths.smk_aggregation,
        paths.annotations if args.annotate else [],
        paths.smk_scanpy_preprocess if "scanpy_preprocess" in config else [],
    output:
        paths.explorer_experiment,
    conda:
        CONDA_ENV
    params:
        explorer = args["explorer"].as_cli(),
        sdata_path = paths.sdata_path,
        explorer_directory = paths.explorer_directory,
    shell:
        """
        sopa explorer write {params.sdata_path} --output-path {params.explorer_directory} {params.explorer} --mode "-it"
        """

rule report:
    input:
        args.segmentation_boundaries(),
        paths.smk_aggregation,
        paths.annotations if args.annotate else [],
        paths.smk_scanpy_preprocess if "scanpy_preprocess" in config else [],
    output:
        paths.report,
    params:
        sdata_path = paths.sdata_path,
        report = paths.report,
    conda:
        CONDA_ENV
    shell:
        """
        sopa report {params.sdata_path} {params.report}
        """
